#!/usr/bin/env python3
"""
Generates terraform repos, users, and roles files for an organization,
based on exported JSON permissions.

Because there is overlap in users between organizations, this
script will not generate module blocks for users that are already
declared by any users_*.tf scripts within the root of this repo;
otherwise, terraform would complain about duplicate users.

Usage:
    python -m edx_import.json_to_terraform ORGANIZATION [--phony]
Or just:
    make edx-import-json-to-terraform

Requirement installation:
    make edx-import-requirements  # in a virtualenv, from repo root

Other requirements:
    * Python >=3.8
    * Expects teams and repositories to be dumped to
     `edx_import/export-{ORGANIZATION].json`.

Linting:
    make edx-import-requirements-dev  # in a virtualenv, from repo root
    make edx-import-lint
"""


# pylint: disable=unspecified-encoding
import json
import os
import sys
from collections import defaultdict
from dataclasses import dataclass
from typing import Dict, List, NewType, Set

from .utils import (REPO_ADMIN, REPO_MAINTAIN, REPO_READ, REPO_WRITE,
                    RepoAccessLevel, RepoName, TeamSlug, Username,
                    access_level_to_string)

# Types for Terraform labels.
# A "label" is that string that goes next to resource type or module name
# in a Terraform block.
# For example, in these blocks:
#   resource "resourcetype" "blah1" { ... }
#   module "blah2" { source = "./module/moduletype", ... }
# the labels are "blah1" and "blah2".
# Labels are used as the primary identifier for a Terraform block.
# Per Terraform style, they should be lowercase and contain only [a-z0-9_],
# so not dots, dashes, or spaces.
RoleLabel = NewType("RoleLabel", str)
RepoLabel = NewType("RepoLabel", str)
UserLabel = NewType("UserLabel", str)


@dataclass
class TerraRole:
    """
    A role grants a set of repository permissions to a set of users.

    Each of these roles will be represented as a Terraform module
    invocation.
    """

    label: RoleLabel
    repo_access: Dict[RepoName, RepoAccessLevel]
    members: Set[Username]


def main():
    """
    Script entrypoint
    """
    # pylint: disable=too-many-locals,too-many-branches,too-many-statements
    assert 2 <= len(sys.argv) <= 3, "Expected 1-2 args: ORGANIZATION [--phony]"

    org_slug = sys.argv[1]
    input_json_fpath = f"edx_import/export-{org_slug}.json"
    output_repos_fpath = f"repos_{org_slug}.tf"
    output_users_fpath = f"users_{org_slug}.tf"
    output_roles_fpath = f"roles_{org_slug}.tf"

    if len(sys.argv) == 3:
        assert sys.argv[2] == "--phony"
        phony_repos = True
    else:
        phony_repos = False

    # Load JSON generated by export_edx_to_json.py
    export = get_export(input_json_fpath)
    export_timestamp: str = export["export_date_utc"]
    export_comment = (
        f"// This file was automatically generated based on the contents of\n"
        f"// the {org_slug!r} GitHub organization as of {export_timestamp}.\n"
        "// It is likely to be reorganized, refactored, split, or combined with\n"
        "// other Terraform files in the near future."
    )

    # Get map from teams to member lists.
    team_members = {team["slug"]: team["members"] for team in export["teams"]}

    # Calculate repo access granted to each team and user.
    team_repo_access: Dict[TeamSlug, Dict[RepoName, RepoAccessLevel]] = defaultdict(
        dict
    )
    user_repo_access: [Username, Dict[RepoName, RepoAccessLevel]] = defaultdict(dict)
    for repo in export["repos"]:
        repo_name = repo["name"]
        # Recall that: all repos in the export are public.
        # Since there's no reason we need to spell out read permissions for anyone,
        # we drop any access grants that aren't at least "write" level.
        for team_slug, access_level in repo["team_access"].items():
            if access_level >= REPO_WRITE:
                team_repo_access[TeamSlug(team_slug)][repo_name] = access_level
        for username, access_level in repo["user_access"].items():
            if access_level >= REPO_WRITE:
                user_repo_access[Username(username)][repo_name] = access_level

    roles_to_create: List[TerraRole] = []

    # Each team gets a role.
    for team_slug, repo_access in team_repo_access.items():
        if not (repo_access and team_members[team_slug]):
            # No access granted to this role, or no users? Drop it.
            continue
        roles_to_create.append(
            TerraRole(
                label=team_slug_to_role_label(org_slug, team_slug),
                repo_access=repo_access,
                members=team_members[team_slug],
            )
        )

    # Each user with special permissions gets their own special little role
    # for now.
    for username, repo_access in user_repo_access.items():
        if not repo_access:
            # No access granted to this user? Don't make them a special role.
            continue
        roles_to_create.append(
            TerraRole(
                label=username_to_role_label(org_slug, username),
                repo_access=repo_access,
                members=[username],
            )
        )

    # Turn every referenced repo into a (disabled) 'repo' module invocations.
    # Don't bother indenting nicely; that's what `terraform fmt` is for.
    repo_names_to_labels: Dict[RepoName, RepoLabel] = {
        # Repo names may come up more than once (accessible by more than one
        # role); Python handles this by taking the latest entry, which is fine.
        repo_name: repo_name_to_repo_label(repo_name)
        for role in roles_to_create
        for repo_name in role.repo_access.keys()
    }
    sorted_repo_name_label_pairs = sorted(
        repo_names_to_labels.items(), key=lambda item: item[1]
    )
    with open(output_repos_fpath, "w") as repos_file:

        def print_repos(*args):
            print(*args, file=repos_file)

        print_repos("// Repositories within the Open edX organization.")
        print_repos()
        print_repos(export_comment)
        for repo_name, repo_label in sorted_repo_name_label_pairs:
            print_repos()
            print_repos(f'module "{repo_label}" {{')
            print_repos('source = "./modules/repo"')
            print_repos(f'name = "{repo_name}"')
            if phony_repos:
                print_repos("phony = true")
            print_repos("}")

    # Turn every referenced user into a 'user' module invocation.
    # Don't bother indenting nicely; that's what `terraform fmt` is for.
    usernames_to_labels: Dict[Username, UserLabel] = {
        # Usernames may come up more than once (members of more than one
        # role); Python handles this by taking the latest entry, which is fine.
        username: username_to_user_label(username)
        for role in roles_to_create
        for username in role.members
    }
    sorted_username_label_pairs = sorted(
        usernames_to_labels.items(), key=lambda item: item[1]
    )
    with open(output_users_fpath, "w") as users_file:

        def print_users(*args):
            print(*args, file=users_file)

        existing_user_labels = get_existing_user_labels()

        print_users(
            "// Users who are members or outside collaborators of Open edX organization.",
        )
        print_users()
        print_users(export_comment)
        for username, user_label in sorted_username_label_pairs:
            if user_label in existing_user_labels:
                continue
            print_users()
            print_users(f'module "{user_label}" {{')
            print_users('source = "./modules/user"')
            print_users(f'username = "{username}"')
            print_users("}")

    # Finally, turn the roles into terraform 'role' module invocations.
    # Don't bother indenting nicely; that's what `terraform fmt` is for.
    with open(output_roles_fpath, "w") as roles_file:

        def print_roles(*args):
            print(*args, file=roles_file)

        print_roles("// Roles, which grant an (ideally logical) collection of")
        print_roles(
            "// repository permissions to one or more Open edX organization users."
        )
        print_roles()
        print_roles(export_comment)

        for role in sorted(roles_to_create, key=lambda role: role.label):

            # Module block header.
            print_roles()
            print_roles(f'module "{role.label}" {{')
            print_roles('source = "./modules/role"')

            # One list of repos for each access level. Example:
            #   admin_repos = [
            #   module.repo_edx_platform,
            #   module.repo_xblock,
            #   ]
            #   write_repos = [
            #   module.repo_frontend_platform,
            #   ]
            for access_level in [REPO_ADMIN, REPO_MAINTAIN, REPO_WRITE, REPO_READ]:
                access_string = access_level_to_string(access_level)
                repo_labels_for_access_level = sorted(
                    [
                        repo_name_to_repo_label(repo_name)
                        for repo_name, repo_access_level in role.repo_access.items()
                        if repo_access_level == access_level
                    ]
                )
                if repo_labels_for_access_level:
                    print_roles(f"{access_string}_repos = [")
                    for repo_label in repo_labels_for_access_level:
                        print_roles(f"module.{repo_label},")
                    print_roles("]")

            # Enumerate role members, alphabetized,
            print_roles("users = [")
            for member in sorted(member.lower() for member in role.members):
                member_label: UserLabel = username_to_user_label(member)
                print_roles(f"module.{member_label},")
            print_roles("]")

            # Closing brace for module block.
            print_roles("}")


def get_export(fpath: str) -> dict:
    """
    Load up export of team memberships and repo access.
    """
    with open(fpath) as export_file:
        return json.loads(export_file.read())


def team_slug_to_role_label(org_slug: str, team_slug: TeamSlug) -> RoleLabel:
    """
    Turn team slug into terraform role label,
    ensuring label is prefixed with 'role_ORG_', but
    avoiding naming roles like 'role_ORG_ORG_'.
    """
    org_slug_dash = org_slug + "-"  # eg, 'edx-'
    if team_slug.startswith(org_slug_dash):
        team_slug_no_org = team_slug[len(org_slug_dash) :]
    elif team_slug.startswith(org_slug_dash):
        team_slug_no_org = team_slug[len(org_slug) :]
    else:
        team_slug_no_org = team_slug
    return RoleLabel(f"role_{org_slug}_{make_name_label_safe(team_slug_no_org)}")


def username_to_role_label(org_slug: str, username: Username) -> RoleLabel:
    """
    Convert username to terraform label for individual user permission role.
    """
    return RoleLabel(f"role_{org_slug}_user_{make_name_label_safe(username)}")


def username_to_user_label(username: Username) -> UserLabel:
    """
    Convert username to terraform label for user module block.
    """
    return UserLabel(f"user_{make_name_label_safe(username)}")


def repo_name_to_repo_label(repo_name: RepoName) -> RepoLabel:
    """
    Convert repository name to terraform label for repo module block.
    """
    return RepoLabel(f"repo_{make_name_label_safe(repo_name)}")


def get_existing_user_labels() -> Set[UserLabel]:
    """
    Return set of users declared in existing `users_*.tf` files.
    """
    user_labels: Set[UserLabel] = set()
    for dir_item in os.listdir("."):
        if not (dir_item.startswith("users_") and dir_item.endswith(".tf")):
            continue
        with open(dir_item) as users_tf_file:
            for line in users_tf_file.readlines():
                if line.startswith('module "') and line.endswith('" {\n'):
                    user_labels.add(UserLabel(line.split('"')[1]))
    return user_labels


def make_name_label_safe(name: str) -> str:
    """
    Tweak name such that it follows Terraform's label style rules.

    Assumes string is already [A-Za-z0-9_.-]
    Restricts character set to [a-z0-9_]
    """
    safe_name = name.lower().replace("-", "_").replace(".", "_dot_")
    if safe_name.startswith("_"):
        return safe_name[1:]  # Remove unhelpful leading underscore.
    return safe_name


if __name__ == "__main__":
    main()
